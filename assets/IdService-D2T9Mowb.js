import{w as u,d as s,a as d,g as h,c as f,r as A}from"./index-Dy5ueVnH.js";const o={TICKET:"imis_history_ticket",FTR:"imis_history_ftr",REG:"imis_history_reg",AADHAR:"imis_history_aadhar"},y={reserveIds:async(t,r,a)=>{let i=0;for(;i<5;)try{const e=new Set;for(;e.size<r;)e.add(String(a()));const l=Array.from(e);return await A(s,async g=>{const E=l.map(n=>d(s,t,n));if((await Promise.all(E.map(n=>g.get(n)))).filter(n=>n.exists()).length>0)throw new Error("COLLISION");E.forEach(n=>{g.set(n,{createdAt:new Date})})}),{success:!0,ids:l}}catch(e){if(e.message==="COLLISION"){console.warn(`Batch generation collision (Attempt ${i+1}). Retrying...`),i++;continue}return console.error("Transaction failed:",e),{success:!1,error:e.message}}return{success:!1,error:"Failed to generate unique IDs after multiple retries. System busy or saturated."}},getAllIds:async()=>{console.warn("Fetching ALL IDs is deprecated for generation logic. Use reserveIds instead.");try{const t={ticket:new Set,ftr:new Set,reg:new Set,aadhar:new Set},[r,a,c,i]=await Promise.all([h(f(s,o.TICKET)),h(f(s,o.FTR)),h(f(s,o.REG)),h(f(s,o.AADHAR))]);return r.forEach(e=>t.ticket.add(e.id)),a.forEach(e=>t.ftr.add(e.id)),c.forEach(e=>t.reg.add(e.id)),i.forEach(e=>t.aadhar.add(e.id)),t}catch(t){return console.error("ID Fetch Error:",t),null}},saveBatch:async t=>{try{const r=u(s);return t.ticket?.forEach(a=>{const c=d(s,o.TICKET,String(a));r.set(c,{createdAt:new Date})}),t.ftr?.forEach(a=>{const c=d(s,o.FTR,String(a));r.set(c,{createdAt:new Date})}),t.reg?.forEach(a=>{const c=d(s,o.REG,String(a));r.set(c,{createdAt:new Date})}),t.aadhar?.forEach(a=>{const c=d(s,o.AADHAR,String(a));r.set(c,{createdAt:new Date})}),await r.commit(),{success:!0}}catch(r){return console.error("Error saving batch to Firebase:",r),{success:!1,error:r.message}}}};export{y as IdService};
